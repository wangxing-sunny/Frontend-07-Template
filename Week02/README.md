# 学习笔记
## 深度优先算法(Depth First)
>栈结构 => 先进后出
## 广度优先算法(Breadth First)
> **队列结构 => 先进先出**
> 
从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向
外扩散，直到找到终点。

寻路算法 广度优先搜索**好于**深度优先搜索，但并不是最好的方式

### [路径规划之$A^*$算法](https://zhuanlan.zhihu.com/p/54510444)

### Dijkstra算法
用来寻找图形中节点之间的最短路径。
计算每一个节点距离起点的总移动**代价** 。同时，还需要一个**优先队列结构**。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。

在算法运行的过程中，每次都从优先队列中选出**代价最小**的作为下一个遍历的节点，直到到达终点为止。
### 最佳优先搜索算法
在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。

与Dijkstra算法类似，也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点。这种算法称之为 **最佳优先(Best First)算法**。

缺点是：如果**起点和终点之间存在障碍物**，则最佳优先算法找到的很可能不是最短路径。
### $A^*$算法
$A^*$算法通过下面这个函数来计算每个节点的优先级。
$$ f(n) = g(n) + h(n) $$
其中：
* f(n)是节点n的 ***综合优先级***。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。
* g(n) 是**节点n距离起点的代价**。
* h(n)是**节点n距离终点的预计代价**，这也就是$A^*$算法的***启发函数***。

$A^*$ 算法在运算过程中，每次从优先队列中选取 **f(n)值最小（优先级最高）** 的节点作为下一个待遍历的节点。

另外，$A^*$算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为open_set和close_set。

完整的$A^*$算法描述：
1. 初始化open_set和close_set；
2. 将起点加入open_set中，并设置优先级为0（优先级最高）；
3. 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
### 启发式函数
启发函数会影响A*算法的行为。

在极端情况下，当**启发函数h(n)始终为0**，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。

如果**h(n)始终小于等于节点n到终点的代价**，则A*算法保证**一定**能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。

如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。

如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。

在另外一个极端情况下，如果h()n相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。

由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。

对于网格形式的图，有以下这些启发函数可以使用：
* 如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。

这里的D是指两个相邻节点之间的移动代价，通常是一个固定的常数。
```js
function heuristic(node) {
    const dx = Math.abs(node.x - goal.x)
    const dy = Math.abs(node.y - goal.y)
    return D * (dx + dy)
}
```
* 如果图形中允许朝八个方向移动，则可以使用对角距离。

这里的D2指的是两个斜着相邻节点之间的移动代价。如果所有节点都正方形，则其值就$\sqrt 2 * D$。
```js
function heuristic(node) {
    const dx = Math.abs(node.x - goal.x)
    const dy = Math.abs(node.y - goal.y)
    return D * (dx + dy) + (D2 - 2 * D) * Math.min(dx, dy)
}
```
* 如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。

欧几里得距离是指两个节点之间的直线距离$\sqrt{(p2.x - p1.x)^2 + (p2.y - p1.y)^2}$。
```js
function heuristic(node) {
    const dx = Math.abs(node.x - goal.x)
    const dy = Math.abs(node.y - goal.y)
    return D * Math.sqrt(dx * dx + dy * dy)
}
```

## 二叉堆
* 最大堆
> 父节点的键值总是大于或等于任何一个子节点的键值
* 最小堆
> 父节点的键值总是大于或等于任何一个子节点的键值

用数组表示：第一个元素为根节点，则第`n`个元素的子节点为`2n+1`和`2n+2`，父节点为`Math.floor((i-1)/2)`;

## JS数组

* **push+shift**/**unshift+pop**模拟**队列**
* **push+pop**模拟**栈**
